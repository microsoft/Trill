// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version: 16.0.0.0
//  
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------
namespace Microsoft.StreamProcessing
{
    using System.Linq;
    using System.Text;
    using System.Collections.Generic;
    using System;
    
    /// <summary>
    /// Class to produce the template output
    /// </summary>
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.TextTemplating", "16.0.0.0")]
    internal partial class TemporalIngressTemplate : CommonUnaryTemplate
    {
        /// <summary>
        /// Create the template output
        /// </summary>
        public override string TransformText()
        {
            this.Write("// *********************************************************************\r\n// Copy" +
                    "right (c) Microsoft Corporation.  All rights reserved.\r\n// Licensed under the MI" +
                    "T License\r\n// ******************************************************************" +
                    "***\r\n/*\\\r\n    * Spec:\r\n    *\r\n    * Apply punctuation policy first. This means t" +
                    "hat even dropped events\r\n    * count towards the number of events seen since the" +
                    " last punctuation.\r\n    * For a Time punctuation policy, insert the punctuation " +
                    "before the\r\n    * event whose start time causes the insertion.\r\n    *\r\n    * Mos" +
                    "t complicated part is the bookkeeping. If the disorder policy is\r\n    * not Thro" +
                    "w, then any events that are dropped or adjusted must be kept\r\n    * track of so " +
                    "that matching end events are dealt with.\r\n    *\r\n    * DisorderPolicy.Throw:\r\n  " +
                    "  *   Don\'t drop any events.\r\n    *\r\n    * DisorderPolicy.Drop:\r\n    *   Start e" +
                    "vent: drop if it is out of order and remember it so corresponding\r\n    *   end e" +
                    "vent is also dropped.\r\n    *   End event: drop if its corresponding start event " +
                    "was dropped or if it is out\r\n    *   of order (latter may leave dangling start e" +
                    "vents that never have an end event).\r\n    *   Interval event: drop if it is out " +
                    "of order\r\n    *   Punctuation event: ??\r\n    *\r\n    * DisorderPolicy.Adjust:\r\n  " +
                    "  *   Start event: if out of order, update start time to start time of previous " +
                    "event.\r\n    *   Remember event so corresponding end event is also modified.\r\n   " +
                    " *   End event: if out of order, update start time to start time of previous eve" +
                    "nt.\r\n    *   If not out of order, check to see if corresponding start event had " +
                    "been modified.\r\n    *   If so, then update its end time to the modified start ti" +
                    "me of the start event.\r\n    *   (This is needed so that its end time matches the" +
                    " start time of the corresponding\r\n    *   start event.)\r\n    *   Interval event:" +
                    " if out of order, update start time to start time of previous event.\r\n    *   If" +
                    " its updated start time is now equal to or greater than its end time, drop it.\r\n" +
                    "\\*/\r\n\r\nusing System;\r\nusing System.Diagnostics.Contracts;\r\nusing System.Diagnost" +
                    "ics;\r\nusing System.Linq.Expressions;\r\nusing System.Runtime.CompilerServices;\r\nus" +
                    "ing System.Runtime.Serialization;\r\nusing Microsoft.StreamProcessing;\r\nusing Micr" +
                    "osoft.StreamProcessing.Internal;\r\nusing Microsoft.StreamProcessing.Internal.Coll" +
                    "ections;\r\n\r\n");
  bool partitioned = (partitionString == "Partitioned");
    string baseStructure = partitionString + "StreamEvent<" + adjustedGenericArgs + ">";
    string globalPunctuation = partitioned ? "LowWatermark" : "Punctuation";
    string highWatermark = partitioned ? "partitionHighWatermarks[value.PartitionKey]" : "highWatermark";
    string keyType = !partitioned ? "Microsoft.StreamProcessing.Empty" : "PartitionKey<TKey>";
    string streamEventFromValue = fusionOption == "Disordered" ? ("new " + partitionString + "StreamEvent<" + genericArguments + ">(" + (!partitioned ? string.Empty : "value.PartitionKey, ") + "value.SyncTime, value.OtherTime, default)") : "value";

            this.Write("[assembly: IgnoresAccessChecksTo(\"Microsoft.StreamProcessing\")]\r\n[DataContract]\r\n" +
                    "internal sealed class ");
            this.Write(this.ToStringHelper.ToStringWithCulture(className));
            this.Write(this.ToStringHelper.ToStringWithCulture(genericParameters));
            this.Write(" : ");
            this.Write(this.ToStringHelper.ToStringWithCulture(partitionString));
            this.Write(this.ToStringHelper.ToStringWithCulture(fusionOption == "Disordered" ? "Disordered" : string.Empty));
            this.Write("ObserverSubscriptionBase<");
            this.Write(this.ToStringHelper.ToStringWithCulture(keyOrNothing));
            this.Write(this.ToStringHelper.ToStringWithCulture(inheritBase));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TPayload));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TResult));
            this.Write(">\r\n{\r\n    ");
            this.Write(this.ToStringHelper.ToStringWithCulture(staticCtor));
            this.Write("\r\n");
  if (partitioned) { 
            this.Write("    private static readonly Func<TKey, int> GetHashCode = EqualityComparerExpress" +
                    "ion<TKey>.DefaultGetHashCodeFunction;\r\n");
  } 
            this.Write("\r\n    public ");
            this.Write(this.ToStringHelper.ToStringWithCulture(className));
            this.Write("() { }\r\n\r\n    public ");
            this.Write(this.ToStringHelper.ToStringWithCulture(className));
            this.Write("(\r\n        IObservable<");
            this.Write(this.ToStringHelper.ToStringWithCulture(inheritBase));
            this.Write("> observable,\r\n        string identifier,\r\n        IStreamable<");
            this.Write(this.ToStringHelper.ToStringWithCulture(keyType));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(payloadOrResult));
            this.Write("> streamable,\r\n        IStreamObserver<");
            this.Write(this.ToStringHelper.ToStringWithCulture(keyType));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(payloadOrResult));
            this.Write("> observer,\r\n        DisorderPolicy disorderPolicy,\r\n        ");
            this.Write(this.ToStringHelper.ToStringWithCulture(partitionString));
            this.Write("FlushPolicy flushPolicy,\r\n        PeriodicPunctuationPolicy punctuationPolicy,\r\n");
  if (partitioned) { 
            this.Write("        PeriodicLowWatermarkPolicy lowWatermarkPolicy,\r\n");
  } 
            this.Write("        OnCompletedPolicy onCompletedPolicy,\r\n        IObserver<OutOfOrder");
            this.Write(this.ToStringHelper.ToStringWithCulture(partitionString));
            this.Write("StreamEvent<");
            this.Write(this.ToStringHelper.ToStringWithCulture(genericArguments));
            this.Write(">> diagnosticOutput)\r\n            : base(observable,\r\n                identifier," +
                    "\r\n                streamable,\r\n                observer,\r\n                disord" +
                    "erPolicy,\r\n                flushPolicy,\r\n                punctuationPolicy,\r\n");
  if (partitioned) { 
            this.Write("                lowWatermarkPolicy,\r\n");
  } 
            this.Write("                onCompletedPolicy,\r\n                diagnosticOutput)\r\n    {\r\n   " +
                    "     ");
            this.Write(this.ToStringHelper.ToStringWithCulture(GeneratedBatchName));
            this.Write(" generatedBatch = (");
            this.Write(this.ToStringHelper.ToStringWithCulture(GeneratedBatchName));
            this.Write(") this.currentBatch;\r\n");
  foreach (var f in this.resultRepresentation.AllFields.Where(fld => fld.OptimizeString()))
    {  
            this.Write("        generatedBatch.");
            this.Write(this.ToStringHelper.ToStringWithCulture(f.Name));
            this.Write(".Initialize();\r\n");
  } 
            this.Write(@"    }

    [ContractInvariantMethod]
    [System.Diagnostics.CodeAnalysis.SuppressMessage(""Microsoft.Performance"", ""CA1822:MarkMembersAsStatic"", Justification = ""Required for code contracts."")]
    private void ObjectInvariant()
    {
        Contract.Invariant(this.startEventInformation != null);
");
  if (!partitioned)
    { 
            this.Write("        Contract.Invariant(StreamEvent.MinSyncTime <= this.currentTime);\r\n");
  } 
            this.Write("    }\r\n\r\n    protected override void FlushContents()\r\n    {\r\n        base.FlushCo" +
                    "ntents();\r\n        ");
            this.Write(this.ToStringHelper.ToStringWithCulture(GeneratedBatchName));
            this.Write(" generatedBatch = (");
            this.Write(this.ToStringHelper.ToStringWithCulture(GeneratedBatchName));
            this.Write(") this.currentBatch;\r\n");
  foreach (var f in this.resultRepresentation.AllFields.Where(fld => fld.OptimizeString()))
    {  
            this.Write("        generatedBatch.");
            this.Write(this.ToStringHelper.ToStringWithCulture(f.Name));
            this.Write(".Initialize();\r\n");
  } 
            this.Write("    }\r\n\r\n    public override void OnNext(");
            this.Write(this.ToStringHelper.ToStringWithCulture(inheritBase));
            this.Write(" ");
            this.Write(this.ToStringHelper.ToStringWithCulture(ingressType == "StreamEvent" ? "value" : "inputValue"));
            this.Write(")\r\n    {\r\n        Contract.EnsuresOnThrow<IngressException>(true);\r\n");
  if (ingressType == "Interval")
    { 
            this.Write("        var value = ");
            this.Write(this.ToStringHelper.ToStringWithCulture(partitionString));
            this.Write("StreamEvent.CreateInterval(");
            this.Write(this.ToStringHelper.ToStringWithCulture(!partitioned ? string.Empty : this.partitionFunction("inputValue") + ", "));
            this.Write(this.ToStringHelper.ToStringWithCulture(this.startEdgeFunction("inputValue")));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(this.endEdgeFunction("inputValue")));
            this.Write(", inputValue);\r\n");
  }
    if (fusionOption == "Disordered")
    { 
            this.Write(this.ToStringHelper.ToStringWithCulture(leadingText));
            this.Write("\r\n        Action(value.SyncTime, ");
            this.Write(this.ToStringHelper.ToStringWithCulture(generatedEndTimeVariable));
            this.Write(", transformedValue, ");
            this.Write(this.ToStringHelper.ToStringWithCulture(!partitioned ? "Microsoft.StreamProcessing.Empty.Default" : "new PartitionKey<TKey>(value.PartitionKey)"));
            this.Write(");\r\n");
            this.Write(this.ToStringHelper.ToStringWithCulture(trailingText));
            this.Write("\r\n    }\r\n\r\n    private void Action(long start, long end, ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TResult));
            this.Write(" payload, ");
            this.Write(this.ToStringHelper.ToStringWithCulture(keyType));
            this.Write(" actionKey)\r\n    {\r\n        var value = new ");
            this.Write(this.ToStringHelper.ToStringWithCulture(partitionString));
            this.Write("StreamEvent<");
            this.Write(this.ToStringHelper.ToStringWithCulture(!partitioned ? string.Empty : "TKey, "));
            this.Write(this.ToStringHelper.ToStringWithCulture(TResult));
            this.Write(">(");
            this.Write(this.ToStringHelper.ToStringWithCulture(!partitioned ? string.Empty : "actionKey.Key, "));
            this.Write("start, end, payload);\r\n");
  } 
            this.Write("        if (value.Is");
            this.Write(this.ToStringHelper.ToStringWithCulture(globalPunctuation));
            this.Write(")\r\n        {\r\n            GenerateAndProcess");
            this.Write(this.ToStringHelper.ToStringWithCulture(globalPunctuation));
            this.Write("(value.SyncTime);\r\n            return;\r\n        }\r\n\r\n");
  if (latencyOption == "WithLatency")
    {
        if (partitioned)
        { 
            this.Write("            // Check to see if we need to generate a low watermark due to Periodi" +
                    "cLowWatermarkPolicy\r\n            if (lowWatermarkPolicyType == PeriodicLowWaterm" +
                    "arkPolicyType.Time &&\r\n                value.SyncTime > lowWatermarkTimestampLag" +
                    ")\r\n            {\r\n                var newLowWatermark = value.SyncTime - lowWate" +
                    "rmarkTimestampLag;\r\n                if ((ulong)(newLowWatermark - this.lowWaterm" +
                    "ark.quantizedForLowWatermarkGeneration) >= lowWatermarkGenerationPeriod)\r\n      " +
                    "          {\r\n                    // SyncTime is sufficiently high to generate a " +
                    "new watermark, but first snap it to the nearest generationPeriod boundary\r\n     " +
                    "               var newLowWatermarkSnapped = newLowWatermark.SnapToLeftBoundary((" +
                    "long)lowWatermarkGenerationPeriod);\r\n                    GenerateAndProcessLowWa" +
                    "termark(newLowWatermarkSnapped);\r\n                }\r\n            }\r\n\r\n        if" +
                    " (!this.currentTime.TryGetValue(value.PartitionKey, out long moveFrom) || moveFr" +
                    "om < this.lowWatermark.rawValue)\r\n        {\r\n            moveFrom = this.lowWate" +
                    "rmark.rawValue;\r\n        }\r\n\r\n        if (!partitionHighWatermarks.ContainsKey(v" +
                    "alue.PartitionKey))\r\n        {\r\n            partitionHighWatermarks.Add(value.Pa" +
                    "rtitionKey, this.lowWatermark.rawValue);\r\n\r\n            if (highWatermarkToParti" +
                    "tionsMap.TryGetValue(this.lowWatermark.rawValue, out HashSet<TKey> keySet)) keyS" +
                    "et.Add(value.PartitionKey);\r\n            else highWatermarkToPartitionsMap.Add(t" +
                    "his.lowWatermark.rawValue, new HashSet<TKey> { value.PartitionKey });\r\n        }" +
                    "\r\n");
      }
        else
        { 
            this.Write("        long moveFrom = currentTime;\r\n");
      } 
            this.Write(@"        long moveTo = moveFrom;

        // Events at the reorder boundary or earlier - are handled using default processing policies
        if (value.SyncTime <= moveFrom)
        {
            Process(ref value);
            return;
        }

        var oldTime = ");
            this.Write(this.ToStringHelper.ToStringWithCulture(highWatermark));
            this.Write(";\r\n        if (value.SyncTime > oldTime)\r\n        {\r\n            ");
            this.Write(this.ToStringHelper.ToStringWithCulture(highWatermark));
            this.Write(" = value.SyncTime;\r\n\r\n");
          if (partitioned)
            { 
            this.Write(@"            var oldSet = this.highWatermarkToPartitionsMap[oldTime];
            if (oldSet.Count <= 1) this.highWatermarkToPartitionsMap.Remove(oldTime);
            else oldSet.Remove(value.PartitionKey);

            if (this.highWatermarkToPartitionsMap.TryGetValue(value.SyncTime, out HashSet<TKey> set)) set.Add(value.PartitionKey);
            else this.highWatermarkToPartitionsMap.Add(value.SyncTime, new HashSet<TKey> { value.PartitionKey });

");
          }
            if (ingressType == "StreamEvent" && partitioned)
            {
                PushIndent("    "); 
            this.Write("        if (value.IsData)\r\n        {\r\n            // moveTo for punctuations is u" +
                    "pdated below\r\n");
          } 
            this.Write("            moveTo = value.SyncTime - this.reorderLatency;\r\n            if (moveT" +
                    "o < StreamEvent.MinSyncTime) moveTo = StreamEvent.MinSyncTime;\r\n            if (" +
                    "moveTo < moveFrom) moveTo = moveFrom;\r\n            }\r\n");
          if (ingressType == "StreamEvent" && partitioned)
            {
                PopIndent(); 
            this.Write("        }\r\n\r\n        if (value.IsPunctuation)\r\n        {\r\n            moveTo = Ma" +
                    "th.Max(moveFrom, value.SyncTime);\r\n        }\r\n");
          } 
            this.Write("\r\n        if (moveTo > moveFrom)\r\n        {\r\n            if (priorityQueueSorter " +
                    "!= null)\r\n            {\r\n                ");
            this.Write(this.ToStringHelper.ToStringWithCulture(partitionString));
            this.Write("StreamEvent<");
            this.Write(this.ToStringHelper.ToStringWithCulture(adjustedGenericArgs));
            this.Write(@"> resultEvent;

                while ((!priorityQueueSorter.IsEmpty()) && priorityQueueSorter.Peek().SyncTime <= moveTo)
                {
                    resultEvent = priorityQueueSorter.Dequeue();
                    Process(ref resultEvent);
                }
            }
            else
            {
                // Extract and process data in-order from impatience, until timestamp of moveTo
                PooledElasticCircularBuffer<");
            this.Write(this.ToStringHelper.ToStringWithCulture(baseStructure));
            this.Write("> streamEvents = impatienceSorter.DequeueUntil(");
            this.Write(this.ToStringHelper.ToStringWithCulture(!partitioned ? string.Empty : "value.PartitionKey, "));
            this.Write(" moveTo, out bool recheck);\r\n\r\n                if (streamEvents != null)\r\n       " +
                    "         {\r\n                    ");
            this.Write(this.ToStringHelper.ToStringWithCulture(baseStructure));
            this.Write(@" resultEvent;
                    while ((streamEvents.Count > 0) && ((!recheck) || (streamEvents.PeekFirst().SyncTime <= moveTo)))
                    {
                        resultEvent = streamEvents.Dequeue();
                        Process(ref resultEvent);
                    }
                }

                if (!recheck && (streamEvents != null))
                    impatienceSorter.Return(");
            this.Write(this.ToStringHelper.ToStringWithCulture(!partitioned ? string.Empty : "value.PartitionKey, "));
            this.Write(@" streamEvents);
            }
        }

        if (value.SyncTime == moveTo)
        {
            Process(ref value);
            return;
        }

        // Enqueue value into impatience
        if (priorityQueueSorter != null) priorityQueueSorter.Enqueue(value);
        else impatienceSorter.Enqueue(ref value);

        UpdateCurrentTime(");
 if (partitioned) { 
            this.Write("value.PartitionKey, ");
 } 
            this.Write("moveTo");
 if (partitioned) { 
            this.Write(", fromEvent: false");
 } 
            this.Write(");\r\n    }\r\n\r\n    private void Process(ref ");
            this.Write(this.ToStringHelper.ToStringWithCulture(baseStructure));
            this.Write(" value)\r\n    {\r\n        Contract.EnsuresOnThrow<IngressException>(true);\r\n");
  }

    if (ingressType == "StreamEvent")
    { 
            this.Write("        Contract.Assume(value.SyncTime != value.OtherTime);\r\n\r\n");
  }

    if (ingressType == "StreamEvent" && latencyOption == "WithLatency")
    { 
            this.Write("        if (value.Is");
            this.Write(this.ToStringHelper.ToStringWithCulture(globalPunctuation));
            this.Write(")\r\n        {\r\n            GenerateAndProcess");
            this.Write(this.ToStringHelper.ToStringWithCulture(globalPunctuation));
            this.Write("(value.SyncTime);\r\n            return;\r\n        }\r\n\r\n");
  }
    if (!partitioned)
    { 
            this.Write("        long current = currentTime;\r\n");
  }
    else
    { 
            this.Write(@"        // Update global high water mark if necessary
        highWatermark = Math.Max(highWatermark, value.SyncTime);

        if (punctuationPolicyType == PeriodicPunctuationPolicyType.Time && !lastPunctuationTime.ContainsKey(value.PartitionKey))
            UpdatePunctuation(value.PartitionKey, this.lowWatermark.rawValue, this.lowWatermark.quantizedForPunctuationGeneration);

        // Retrieve current time for this partition, updating currentTime if necessary
        long current;
        if (!currentTime.TryGetValue(value.PartitionKey, out current))
        {
            current = lowWatermark;
        }
        else if (current < lowWatermark)
        {
            current = lowWatermark;
            currentTime[value.PartitionKey] = lowWatermark;
        }
");
  } 
            this.Write("\r\n        var outOfOrder = value.SyncTime < current;\r\n        if (punctuationPoli" +
                    "cyType == PeriodicPunctuationPolicyType.Time)\r\n        {\r\n");
  if (ingressType == "StreamEvent" && partitioned)
    { 
            this.Write("            // Track punctuation\r\n            if (value.IsPunctuation && value.Sy" +
                    "ncTime > lastPunctuationTime[value.PartitionKey].lastPunctuation)\r\n             " +
                    "   UpdatePunctuation(value.PartitionKey, value.SyncTime);\r\n\r\n");
  } 
            this.Write(@"            // out of order events shouldn't count, and if the disorder policy adjusts their sync time, then it
            // will be made equal to a timestamp already seen earlier in the sequence and this would have triggered
            // (if necessary) when that timestamp was seen.
");
  if (!partitioned)
    { 
            this.Write(@"            ulong delta = (ulong)(value.SyncTime - lastPunctuationTime);
            if (!outOfOrder && delta >= punctuationGenerationPeriod)
            {
                // SyncTime is sufficiently high to generate a new punctuation, but first snap it to the nearest generationPeriod boundary
                var punctuationTimeQuantized = value.SyncTime.SnapToLeftBoundary((long)punctuationGenerationPeriod);
#if DEBUG
                Debug.Assert(punctuationTimeQuantized >= LastEventTime(), ""Bug in punctuation quantization logic"");
#endif
                OnPunctuation(StreamEvent.CreatePunctuation<");
            this.Write(this.ToStringHelper.ToStringWithCulture(fusionOption == "Disordered" ? TResult : TPayload));
            this.Write(">(punctuationTimeQuantized));\r\n            }\r\n");
  }
    else
    { 
            this.Write(@"            if (!outOfOrder && this.punctuationGenerationPeriod > 0)
            {
                // We use lowWatermark as the baseline in the delta computation because a low watermark implies
                // punctuations for all partitions
                var prevPunctuation = Math.Max(this.lastPunctuationTime[value.PartitionKey].lastPunctuationQuantized, this.lowWatermark.quantizedForPunctuationGeneration);
                if ((ulong)(value.SyncTime - prevPunctuation) >= this.punctuationGenerationPeriod)
                {
                    // SyncTime is sufficiently high to generate a new punctuation, but first snap it to the nearest generationPeriod boundary
                    var punctuationTimeQuantized = value.SyncTime.SnapToLeftBoundary((long)this.punctuationGenerationPeriod);
#if DEBUG
                    Debug.Assert(punctuationTimeQuantized >= LastEventTime(value.PartitionKey), ""Bug in punctuation quantization logic"");
#endif
                    OnPunctuation(value.CreatePunctuation(punctuationTimeQuantized));
                }
            }
");
  }  
            this.Write("        }\r\n\r\n");
  if (ingressType == "StreamEvent")
    { 
            this.Write("        // check for out of order event\r\n");
      if (partitioned)
        { 
            this.Write("        if (value.IsPunctuation)\r\n        {\r\n            OnPunctuation(value.Crea" +
                    "tePunctuation(outOfOrder ? current : value.SyncTime));\r\n        }\r\n        else\r" +
                    "\n        {\r\n");
              PushIndent("    ");
            }
        } 
            this.Write(@"        if (disorderPolicyType == DisorderPolicyType.Throw)
        {
            if (outOfOrder)
            {
                throw new IngressException($""Out-of-order event encountered during ingress, under a disorder policy of Throw: value.SyncTime: {value.SyncTime}, current: {current}"");
            }
        }
        else
        {
");
      if (ingressType == "StreamEvent")
        { 
            this.Write("            // end events and interval events just get dropped\r\n            Tuple" +
                    "<long, ");
            this.Write(this.ToStringHelper.ToStringWithCulture(fusionOption == "Disordered" ? TResult : TPayload));
            this.Write(@"> key;
            ElasticCircularBuffer<AdjustInfo> q;
            switch (value.Kind)
            {
                case StreamEventKind.Start:
                    if (outOfOrder)
                    {
                        key = Tuple.Create(value.SyncTime, value.Payload);
                        if (!startEventInformation.TryGetValue(key, out q))
                        {
                            q = new ElasticCircularBuffer<AdjustInfo>();
                            startEventInformation.Add(key, q);
                            var x = new AdjustInfo(current);
                            q.Enqueue(ref x);
                        }
                        else
                        {
                            var last = q.PeekLast();
                            if (last.modifiedStartTime == current) last.numberOfOccurrences++;
                            else
                            {
                                var x = new AdjustInfo(current);
                                q.Enqueue(ref x);
                            }
                        }

                        if (disorderPolicyType == DisorderPolicyType.Drop)
                        {
                            diagnosticOutput?.OnNext(OutOfOrder");
            this.Write(this.ToStringHelper.ToStringWithCulture(partitionString));
            this.Write("StreamEvent.Create(");
            this.Write(this.ToStringHelper.ToStringWithCulture(streamEventFromValue));
            this.Write(", new long?()));\r\n                            return; // drop\r\n                  " +
                    "      }\r\n                        else\r\n                        {\r\n              " +
                    "              diagnosticOutput?.OnNext(OutOfOrder");
            this.Write(this.ToStringHelper.ToStringWithCulture(partitionString));
            this.Write("StreamEvent.Create(");
            this.Write(this.ToStringHelper.ToStringWithCulture(streamEventFromValue));
            this.Write(", new long?(current - value.SyncTime)));\r\n                            value = new" +
                    " ");
            this.Write(this.ToStringHelper.ToStringWithCulture(partitionString));
            this.Write("StreamEvent<");
            this.Write(this.ToStringHelper.ToStringWithCulture(adjustedGenericArgs));
            this.Write(">(");
            this.Write(this.ToStringHelper.ToStringWithCulture(!partitioned ? string.Empty : "value.PartitionKey, "));
            this.Write("current, StreamEvent.InfinitySyncTime, value.Payload);\r\n                        }" +
                    "\r\n                    }\r\n                    break;\r\n\r\n                case Stre" +
                    "amEventKind.Interval:\r\n");
      } 
            this.Write("                    if (outOfOrder)\r\n                    {\r\n                     " +
                    "   if (disorderPolicyType == DisorderPolicyType.Drop)\r\n                        {" +
                    "\r\n                            diagnosticOutput?.OnNext(OutOfOrder");
            this.Write(this.ToStringHelper.ToStringWithCulture(partitionString));
            this.Write("StreamEvent.Create(");
            this.Write(this.ToStringHelper.ToStringWithCulture(streamEventFromValue));
            this.Write(@", new long?()));
                            return; // drop
                        }
                        else
                        {
                            if (current >= value.OtherTime)
                            {
                                diagnosticOutput?.OnNext(OutOfOrder");
            this.Write(this.ToStringHelper.ToStringWithCulture(partitionString));
            this.Write("StreamEvent.Create(");
            this.Write(this.ToStringHelper.ToStringWithCulture(streamEventFromValue));
            this.Write(", new long?()));\r\n                                return; // drop\r\n              " +
                    "              }\r\n\r\n                            diagnosticOutput?.OnNext(OutOfOrd" +
                    "er");
            this.Write(this.ToStringHelper.ToStringWithCulture(partitionString));
            this.Write("StreamEvent.Create(");
            this.Write(this.ToStringHelper.ToStringWithCulture(streamEventFromValue));
            this.Write(", new long?(current - value.SyncTime)));\r\n                            value = new" +
                    " ");
            this.Write(this.ToStringHelper.ToStringWithCulture(partitionString));
            this.Write("StreamEvent<");
            this.Write(this.ToStringHelper.ToStringWithCulture(adjustedGenericArgs));
            this.Write(">(");
            this.Write(this.ToStringHelper.ToStringWithCulture(!partitioned ? string.Empty : "value.PartitionKey, "));
            this.Write("current, value.OtherTime, value.Payload);\r\n                        }\r\n           " +
                    "         }\r\n");
      if (ingressType == "StreamEvent")
        { 
            this.Write(@"                    break;

                case StreamEventKind.End:
                    // it may not be out of order, but did we drop/adjust the corresponding start event?
                    key = Tuple.Create(value.OtherTime, value.Payload);
                    if (startEventInformation.TryGetValue(key, out q))
                    {
                        Contract.Assume(!q.IsEmpty());
                        var firstElement = q.PeekFirst();
                        firstElement.numberOfOccurrences--;
                        if (firstElement.numberOfOccurrences == 0)
                        {
                            q.Dequeue(); // throw away returned value
                            if (q.Count == 0) startEventInformation.Remove(key);
                        }
                        var adjustedTime = firstElement.modifiedStartTime;

                        if (disorderPolicyType == DisorderPolicyType.Drop)
                        {
                            diagnosticOutput?.OnNext(OutOfOrder");
            this.Write(this.ToStringHelper.ToStringWithCulture(partitionString));
            this.Write("StreamEvent.Create(");
            this.Write(this.ToStringHelper.ToStringWithCulture(streamEventFromValue));
            this.Write(", new long?()));\r\n                            return; // drop\r\n                  " +
                    "      }\r\n                        else\r\n                        {\r\n              " +
                    "              diagnosticOutput?.OnNext(OutOfOrder");
            this.Write(this.ToStringHelper.ToStringWithCulture(partitionString));
            this.Write("StreamEvent.Create(");
            this.Write(this.ToStringHelper.ToStringWithCulture(streamEventFromValue));
            this.Write(", new long?(current - value.SyncTime)));\r\n                            value = new" +
                    " ");
            this.Write(this.ToStringHelper.ToStringWithCulture(partitionString));
            this.Write("StreamEvent<");
            this.Write(this.ToStringHelper.ToStringWithCulture(adjustedGenericArgs));
            this.Write(">(");
            this.Write(this.ToStringHelper.ToStringWithCulture(!partitioned ? string.Empty : ("value.PartitionKey, ")));
            this.Write(@"outOfOrder ? current : value.SyncTime, adjustedTime, value.Payload);
                        }
                    }
                    else if (outOfOrder)
                    {
                        if (disorderPolicyType == DisorderPolicyType.Drop)
                        {
                            diagnosticOutput?.OnNext(OutOfOrder");
            this.Write(this.ToStringHelper.ToStringWithCulture(partitionString));
            this.Write("StreamEvent.Create(");
            this.Write(this.ToStringHelper.ToStringWithCulture(streamEventFromValue));
            this.Write(", new long?()));\r\n                            return; // drop\r\n                  " +
                    "      }\r\n                        else\r\n                        {\r\n              " +
                    "              diagnosticOutput?.OnNext(OutOfOrder");
            this.Write(this.ToStringHelper.ToStringWithCulture(partitionString));
            this.Write("StreamEvent.Create(");
            this.Write(this.ToStringHelper.ToStringWithCulture(streamEventFromValue));
            this.Write(", new long?(current - value.SyncTime)));\r\n                            value = new" +
                    " ");
            this.Write(this.ToStringHelper.ToStringWithCulture(partitionString));
            this.Write("StreamEvent<");
            this.Write(this.ToStringHelper.ToStringWithCulture(adjustedGenericArgs));
            this.Write(">(");
            this.Write(this.ToStringHelper.ToStringWithCulture(!partitioned ? string.Empty : ("value.PartitionKey, ")));
            this.Write(@"current, value.OtherTime, value.Payload);
                        }
                    }

                    break;
                default:
                    Contract.Assert(false, ""switch meant to be exhaustive"");
                    throw new InvalidOperationException(""Unsupported stream event kind: "" + value.Kind.ToString());
            }
");
      } 
            this.Write("        }\r\n\r\n");
      PushIndent("            "); 
            this.Write(this.ToStringHelper.ToStringWithCulture(fusionOption == "Fused" ? leadingText : string.Empty));
            this.Write("\r\n");
      AddToGeneratedBatch(); 
            this.Write(this.ToStringHelper.ToStringWithCulture(fusionOption == "Fused" ? trailingText : string.Empty));
            this.Write("\r\n");
      PopIndent(); 
      if (partitioned && ingressType == "StreamEvent")
        {
            PopIndent(); 
            this.Write("        }\r\n");
      } 
            this.Write("\r\n        UpdateCurrentTime(");
 if (partitioned) { 
            this.Write("value.PartitionKey, ");
 } 
            this.Write("value.SyncTime);\r\n    }\r\n\r\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]" +
                    "\r\n    private void UpdateCurrentTime(");
 if (partitioned) { 
            this.Write("TKey partitionKey, ");
 } 
            this.Write("long time");
 if (partitioned) { 
            this.Write(", bool fromEvent = true");
 } 
            this.Write(")\r\n    {\r\n");
      if (!partitioned)
        { 
            this.Write("        if (this.currentTime < time)\r\n        {\r\n            this.currentTime = t" +
                    "ime;\r\n        }\r\n");
      }
        else
        { 
            this.Write(@"        if (!this.currentTime.TryGetValue(partitionKey, out long oldCurrentTime) || oldCurrentTime < time)
        {
            this.currentTime[partitionKey] = time;
        }
#if DEBUG
        if (fromEvent && (!this.lastEventTime.TryGetValue(partitionKey, out long oldEventTime) || oldEventTime < time))
        {
            this.lastEventTime[partitionKey] = time;
        }
#endif
");
      }
            this.Write("    }\r\n\r\n    private void GenerateAndProcess");
            this.Write(this.ToStringHelper.ToStringWithCulture(globalPunctuation));
            this.Write("(long syncTime)\r\n    {\r\n        if (syncTime <= ");
            this.Write(this.ToStringHelper.ToStringWithCulture(partitioned ? "this.lowWatermark.rawValue" : "this.lastPunctuationTime"));
            this.Write(") return;\r\n\r\n");
      if (!partitioned)
        { 
            this.Write("            // Update the ");
            this.Write(this.ToStringHelper.ToStringWithCulture(globalPunctuation));
            this.Write(" to be at least the currentTime, so the ");
            this.Write(this.ToStringHelper.ToStringWithCulture(globalPunctuation));
            this.Write("\r\n            // is not before the preceding data event.\r\n");
          if (latencyOption == "WithLatency")
            { 
            this.Write("            // Note that currentTime only reflects events already processed, and " +
                    "excludes events in the reorder buffer.\r\n");
          } 
            this.Write("            syncTime = Math.Max(syncTime, this.currentTime);\r\n");
      } 
            this.Write("\r\n");
      if (latencyOption == "WithLatency")
        { 
            this.Write("        // Process events queued for reorderLatency up to the ");
            this.Write(this.ToStringHelper.ToStringWithCulture(globalPunctuation));
            this.Write(" syncTime\r\n        if (priorityQueueSorter != null)\r\n        {\r\n            ");
            this.Write(this.ToStringHelper.ToStringWithCulture(baseStructure));
            this.Write(@" resultEvent;
            while ((!priorityQueueSorter.IsEmpty()) && priorityQueueSorter.Peek().SyncTime <= syncTime)
            {
                resultEvent = priorityQueueSorter.Dequeue();
                Process(ref resultEvent);
            }
        }
        else
        {
");
          if (partitioned)
            { 
            this.Write("            bool recheck;\r\n            var PartitionedstreamEvents = impatienceSo" +
                    "rter.DequeueUntil(syncTime);\r\n\r\n            int index = FastDictionary<TKey, Tup" +
                    "le<bool, PooledElasticCircularBuffer<PartitionedStreamEvent<TKey, ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TPayload));
            this.Write(">>>>.IteratorStart;\r\n            while(");
            this.Write(this.ToStringHelper.ToStringWithCulture(partitionString));
            this.Write("streamEvents.Iterate(ref index))\r\n            {\r\n                var entry = ");
            this.Write(this.ToStringHelper.ToStringWithCulture(partitionString));
            this.Write("streamEvents.entries[index];\r\n                recheck = entry.value.Item1;\r\n     " +
                    "           var streamEvents = entry.value.Item2;\r\n");
              PushIndent("    ");
            }
            else
            { 
            this.Write("            var streamEvents = impatienceSorter.DequeueUntil(syncTime, out bool r" +
                    "echeck);\r\n");
          } 
            this.Write("            if (streamEvents != null)\r\n            {\r\n                ");
            this.Write(this.ToStringHelper.ToStringWithCulture(baseStructure));
            this.Write(@" resultEvent;
                while ((streamEvents.Count > 0) && ((!recheck) || (streamEvents.PeekFirst().SyncTime <= syncTime)))
                {
                    resultEvent = streamEvents.Dequeue();
                    Process(ref resultEvent);
                }
                if (!recheck) impatienceSorter.Return(");
            this.Write(this.ToStringHelper.ToStringWithCulture(!partitioned ? string.Empty : "entry.key , "));
            this.Write(" streamEvents);\r\n            }\r\n");
          if (partitioned)
            {
                PopIndent(); 
            this.Write("            }\r\n");
          } 
            this.Write("        }\r\n\r\n");
      } 
            this.Write("        // Update cached global times\r\n        highWatermark = Math.Max(syncTime," +
                    " highWatermark);\r\n");
      if (partitioned)
        { 
            this.Write(@"        if (this.lowWatermark.rawValue < syncTime)
        {
            UpdateLowWatermark(syncTime)

            // Gather keys whose high watermarks are before the new low watermark
            var expiredWatermarkKVPs = new List<KeyValuePair<long, HashSet<TKey>>>();
            foreach (var keyValuePair in highWatermarkToPartitionsMap)
            {
                // Since highWatermarkToPartitionsMap is sorted, we can stop as soon as we reach the threshold
                if (keyValuePair.Key >= this.lowWatermark.rawValue) break;

                expiredWatermarkKVPs.Add(keyValuePair);
            }

            // Clean up state from expired partitions
            foreach (var expiredWatermarkKVP in expiredWatermarkKVPs)
            {
                var expiredWatermark = expiredWatermarkKVP.Key;
                this.highWatermarkToPartitionsMap.Remove(expiredWatermark);

                var expiredKeys = expiredWatermarkKVP.Value;
                foreach (var expiredKey in expiredKeys)
                {
                    this.lastPunctuationTime.Remove(expiredKey);
                    this.partitionHighWatermarks.Remove(expiredKey);
                    this.currentTime.Remove(expiredKey);
#if DEBUG
                    this.lastEventTime.Remove(expiredKey);
#endif
                }
            }
        }
");
      }
        else
        { 
            this.Write("        UpdateCurrentTime(syncTime);\r\n        this.lastPunctuationTime = Math.Max" +
                    "(\r\n            syncTime.SnapToLeftBoundary((long)this.punctuationGenerationPerio" +
                    "d),\r\n            this.lastPunctuationTime);\r\n");
      } 
            this.Write("\r\n        // Add ");
            this.Write(this.ToStringHelper.ToStringWithCulture(globalPunctuation));
            this.Write(" to batch\r\n        var count = currentBatch.Count;\r\n        currentBatch.vsync.co" +
                    "l[count] = syncTime;\r\n        currentBatch.vother.col[count] = ");
            this.Write(this.ToStringHelper.ToStringWithCulture(partitionString));
            this.Write("StreamEvent.");
            this.Write(this.ToStringHelper.ToStringWithCulture(globalPunctuation));
            this.Write(@"OtherTime;
        currentBatch.bitvector.col[count >> 6] |= (1L << (count & 0x3f));
        currentBatch.key.col[count] = default;
        currentBatch[count] = default;
        currentBatch.hash.col[count] = 0;
        currentBatch.Count = count + 1;

        // Flush if necessary
        if (flushPolicy == ");
            this.Write(this.ToStringHelper.ToStringWithCulture(partitionString));
            this.Write("FlushPolicy.FlushOn");
            this.Write(this.ToStringHelper.ToStringWithCulture(globalPunctuation));
            this.Write(" ||\r\n            (flushPolicy == ");
            this.Write(this.ToStringHelper.ToStringWithCulture(partitionString));
            this.Write("FlushPolicy.FlushOnBatchBoundary && currentBatch.Count == Config.DataBatchSize))\r" +
                    "\n        {\r\n            OnFlush();\r\n        }\r\n        else if (currentBatch.Cou" +
                    "nt == Config.DataBatchSize)\r\n        {\r\n            FlushContents();\r\n        }\r" +
                    "\n    }\r\n\r\n");
      if (partitioned && latencyOption == "WithLatency")
        { 
            this.Write(@"    protected override void UpdatePointers()
    {
        foreach (var kvp in partitionHighWatermarks)
        {
            if (highWatermarkToPartitionsMap.TryGetValue(kvp.Value, out HashSet<TKey> set))
                set.Add(kvp.Key);
            else
                highWatermarkToPartitionsMap.Add(kvp.Value, new HashSet<TKey> { kvp.Key });
        }
    }

");
      } 
            this.Write("    protected override void OnCompleted(long punctuationTime)\r\n    {\r\n        Gen" +
                    "erateAndProcess");
            this.Write(this.ToStringHelper.ToStringWithCulture(globalPunctuation));
            this.Write("(punctuationTime);\r\n\r\n        // Flush, but if we just flushed due to the punctua" +
                    "tion generated above\r\n        if (flushPolicy != ");
            this.Write(this.ToStringHelper.ToStringWithCulture(partitionString));
            this.Write("FlushPolicy.FlushOn");
            this.Write(this.ToStringHelper.ToStringWithCulture(globalPunctuation));
            this.Write(")\r\n            OnFlush();\r\n    }\r\n}\r\n\r\n");
            return this.GenerationEnvironment.ToString();
        }

private void AddToGeneratedBatch()
{

this.Write("{\r\n    ");

this.Write(this.ToStringHelper.ToStringWithCulture(GeneratedBatchName));

this.Write(" generatedBatch = (");

this.Write(this.ToStringHelper.ToStringWithCulture(GeneratedBatchName));

this.Write(") this.currentBatch;\r\n    var count = currentBatch.Count;\r\n    currentBatch.vsync" +
        ".col[count] = value.SyncTime;\r\n    currentBatch.vother.col[count] = ");

this.Write(this.ToStringHelper.ToStringWithCulture(generatedEndTimeVariable));

this.Write(";\r\n    currentBatch.key.col[count] = ");

this.Write(this.ToStringHelper.ToStringWithCulture(emptyOrPartition));

this.Write(";\r\n    currentBatch.hash.col[count] = ");

this.Write(this.ToStringHelper.ToStringWithCulture(partitionString == "Partitioned" ? "GetHashCode(value.PartitionKey)" : "0"));

this.Write(";\r\n");

 if (resultRepresentation.noFields)
    { 
this.Write("    generatedBatch.payload.col[count] = ");

this.Write(this.ToStringHelper.ToStringWithCulture(valueString));

this.Write(";\r\n");

 }
    else
    { 
     if (this.resultMightBeNull)
        { 
this.Write("    if (");

this.Write(this.ToStringHelper.ToStringWithCulture(valueString));

this.Write(" == null)\r\n    {\r\n        generatedBatch._nullnessvector.col[count >> 6] |= (1L <" +
        "< (count & 0x3f));\r\n    }\r\n    else\r\n    {\r\n");

         PushIndent("    ");
        } 
     foreach (var f in resultRepresentation.AllFields)
        {
            if (f.OptimizeString())
            { 
this.Write("        generatedBatch.");

this.Write(this.ToStringHelper.ToStringWithCulture(f.Name));

this.Write(".AddString(");

this.Write(this.ToStringHelper.ToStringWithCulture(valueString));

this.Write(".");

this.Write(this.ToStringHelper.ToStringWithCulture(f.OriginalName));

this.Write(");\r\n");

         }
            else
            { 
this.Write("        generatedBatch.");

this.Write(this.ToStringHelper.ToStringWithCulture(f.Name));

this.Write(".col[count] = ");

this.Write(this.ToStringHelper.ToStringWithCulture(valueString));

this.Write(".");

this.Write(this.ToStringHelper.ToStringWithCulture(f.OriginalName));

this.Write(";\r\n");

         }
        }
    }  
 if (this.resultMightBeNull)
    {
        PopIndent(); 
this.Write("    }\r\n");

 } 
this.Write("\r\n    currentBatch.Count++;\r\n    if (currentBatch.Count == Config.DataBatchSize)\r" +
        "\n    {\r\n        if (flushPolicy == ");

this.Write(this.ToStringHelper.ToStringWithCulture(partitionString));

this.Write("FlushPolicy.FlushOnBatchBoundary) OnFlush();\r\n        else FlushContents();\r\n    " +
        "}\r\n}\r\n");


}

    }
}

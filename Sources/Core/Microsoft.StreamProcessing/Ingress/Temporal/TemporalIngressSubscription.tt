<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
// *********************************************************************
// Copyright (c) Microsoft Corporation.  All rights reserved.
// Licensed under the MIT License
// *********************************************************************
/*\
    * Spec:
    *
    * Apply punctuation policy first. This means that even dropped events
    * count towards the number of events seen since the last punctuation.
    * For a Time punctuation policy, insert the punctuation before the
    * event whose start time causes the insertion.
    *
    * Most complicated part is the bookkeeping. If the disorder policy is
    * not Throw, then any events that are dropped or adjusted must be kept
    * track of so that matching end events are dealt with.
    *
    * DisorderPolicy.Throw:
    *   Don't drop any events.
    *
    * DisorderPolicy.Drop:
    *   Start event: drop if it is out of order and remember it so corresponding
    *   end event is also dropped.
    *   End event: drop if its corresponding start event was dropped or if it is out
    *   of order (latter may leave dangling start events that never have an end event).
    *   Interval event: drop if it is out of order
    *   Punctuation event: ??
    *
    * DisorderPolicy.Adjust:
    *   Start event: if out of order, update start time to start time of previous event.
    *   Remember event so corresponding end event is also modified.
    *   End event: if out of order, update start time to start time of previous event.
    *   If not out of order, check to see if corresponding start event had been modified.
    *   If so, then update its end time to the modified start time of the start event.
    *   (This is needed so that its end time matches the start time of the corresponding
    *   start event.)
    *   Interval event: if out of order, update start time to start time of previous event.
    *   If its updated start time is now equal to or greater than its end time, drop it.
\*/

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Diagnostics.Contracts;
using System.Linq;
using System.Linq.Expressions;
using System.Runtime.CompilerServices;
using System.Runtime.Serialization;
using Microsoft.StreamProcessing.Internal;
using Microsoft.StreamProcessing.Internal.Collections;

namespace Microsoft.StreamProcessing
{
<#  foreach (string partitionString in new string[] { string.Empty, "Partitioned" })
    foreach (string ingressType in new string[] { "StreamEvent", "Interval" })
    {
        bool partitioned = (partitionString == "Partitioned");
        string genericArguments = !partitioned ? "TPayload" : "TKey, TPayload";
        string keyType = !partitioned ? "Empty" : "PartitionKey<TKey>";
        string ingress =
              (ingressType == "StreamEvent" ? partitionString + "StreamEvent<" : string.Empty)
            + (!partitioned || ingressType != "StreamEvent" ? "TPayload" : "TKey, TPayload")
            + (ingressType == "StreamEvent" ? ">" : string.Empty);
        string expressionArguments = null;
        switch (ingressType)
        {
            case "StreamEvent":
                expressionArguments = string.Empty;
                break;
            case "Interval":
                expressionArguments = ((!partitioned ? string.Empty : "partitionExtractor, ") + "startEdgeExtractor, endEdgeExtractor, ");
                break;
        }#>
    internal static class <#= partitionString #><#= ingressType #>SubscriptionCreator<<#= genericArguments #>, TResult>
    {
        public static IIngressStreamObserver CreateSubscription(
            IObservable<<#= ingress #>> observable,
<#      if (ingressType == "Interval")
        {
            if (partitioned)
            { #>
            Expression<Func<TPayload, TKey>> partitionExtractor,
<#          } #>
            Expression<Func<TPayload, long>> startEdgeExtractor,
            Expression<Func<TPayload, long>> endEdgeExtractor,
<#      } #>
            string identifier,
            Streamable<<#= keyType #>, TResult> streamable,
            IStreamObserver<<#= keyType #>, TResult> observer,
            DisorderPolicy disorderPolicy,
            <#= partitionString #>FlushPolicy flushPolicy,
            PeriodicPunctuationPolicy punctuationPolicy,
<#  if (partitioned) { #>
            PeriodicLowWatermarkPolicy lowWatermarkPolicy,
<#  } #>
            OnCompletedPolicy onCompletedPolicy,
            IObserver<OutOfOrder<#= partitionString #>StreamEvent<<#= genericArguments #>>> diagnosticOutput,
            FuseModule fuseModule)
        {
            if (punctuationPolicy.type != PeriodicPunctuationPolicyType.Time && punctuationPolicy.type != PeriodicPunctuationPolicyType.None)
            {
                throw new InvalidOperationException("Invalid punctuation policy: " + punctuationPolicy.ToString());
            }

<#  if (partitioned) { #>
            if (lowWatermarkPolicy.type != PeriodicLowWatermarkPolicyType.Time && lowWatermarkPolicy.type != PeriodicLowWatermarkPolicyType.None)
            {
                throw new InvalidOperationException("Invalid punctuation policy: " + lowWatermarkPolicy.ToString());
            }

<#  } #>
            if (disorderPolicy.reorderLatency > 0)
            {
                if (fuseModule.IsEmpty)
                    return new Simple<#= partitionString #><#= ingressType #>SubscriptionWithLatency<<#= genericArguments #>>(observable, <#= expressionArguments #>identifier, (Streamable<<#= keyType #>, TPayload>)(object)streamable, (IStreamObserver<<#= keyType #>, TPayload>)(object)observer, disorderPolicy, flushPolicy, punctuationPolicy, <#= partitioned ? "lowWatermarkPolicy, " : string.Empty #>onCompletedPolicy, diagnosticOutput);
                else if (Config.AllowFloatingReorderPolicy)
                    return new Disordered<#= partitionString #><#= ingressType #>SubscriptionWithLatency<<#= genericArguments #>, TResult>(observable, fuseModule, <#= expressionArguments #>identifier, streamable, observer, disorderPolicy, flushPolicy, punctuationPolicy, <#= partitioned ? "lowWatermarkPolicy, " : string.Empty #>onCompletedPolicy, diagnosticOutput);
                else
                    return new Fused<#= partitionString #><#= ingressType #>SubscriptionWithLatency<<#= genericArguments #>, TResult>(observable, fuseModule, <#= expressionArguments #>identifier, streamable, observer, disorderPolicy, flushPolicy, punctuationPolicy, <#= partitioned ? "lowWatermarkPolicy, " : string.Empty #>onCompletedPolicy, diagnosticOutput);
            }
            else
            {
                if (fuseModule.IsEmpty)
                    return new Simple<#= partitionString #><#= ingressType #>Subscription<<#= genericArguments #>>(observable, <#= expressionArguments #>identifier, (Streamable<<#= keyType #>, TPayload>)(object)streamable, (IStreamObserver<<#= keyType #>, TPayload>)(object)observer, disorderPolicy, flushPolicy, punctuationPolicy, <#= partitioned ? "lowWatermarkPolicy, " : string.Empty #>onCompletedPolicy, diagnosticOutput);
                else if (Config.AllowFloatingReorderPolicy)
                    return new Disordered<#= partitionString #><#= ingressType #>Subscription<<#= genericArguments #>, TResult>(observable, fuseModule, <#= expressionArguments #>identifier, streamable, observer, disorderPolicy, flushPolicy, punctuationPolicy, <#= partitioned ? "lowWatermarkPolicy, " : string.Empty #>onCompletedPolicy, diagnosticOutput);
                else
                    return new Fused<#= partitionString #><#= ingressType #>Subscription<<#= genericArguments #>, TResult>(observable, fuseModule, <#= expressionArguments #>identifier, streamable, observer, disorderPolicy, flushPolicy, punctuationPolicy, <#= partitioned ? "lowWatermarkPolicy, " : string.Empty #>onCompletedPolicy, diagnosticOutput);
            }
        }
    }

<# } // end foreach loops

    foreach (string partitionString in new string[] { string.Empty, "Partitioned" })
    foreach (string ingressType in new string[] { "StreamEvent", "Interval" })
    foreach (string latencyOption in new string[] { "WithLatency", string.Empty })
    foreach (string fusionOption in new string[] { "Simple", "Fused", "Disordered" })
    {
        bool partitioned = (partitionString == "Partitioned");
        string className = fusionOption + partitionString + ingressType + "Subscription" + latencyOption;
        string genericArguments = !partitioned ? "TPayload" : "TKey, TPayload";
        string adjustedGenericArgs = fusionOption == "Disordered" ? genericArguments.Replace("TPayload", "TResult") : genericArguments;
        string keyType = !partitioned ? "Empty" : "PartitionKey<TKey>";
        string outputType = fusionOption != "Simple" ? "TResult" : "TPayload";
        string inheritBase = (ingressType != "StreamEvent") ? "TPayload" : (partitionString + "StreamEvent<" + genericArguments + ">");
        string baseStructure = partitionString + "StreamEvent<" + adjustedGenericArgs + ">";
        string highWatermark = partitioned ? "this.partitionHighWatermarks[value.PartitionKey]" : "this.highWatermark";
        string globalPunctuation= partitioned ? "LowWatermark" : "Punctuation";
        string streamEventFromValue = fusionOption == "Disordered" ? ("new " + partitionString + "StreamEvent<" + genericArguments + ">(" + (!partitioned ? string.Empty : "value.PartitionKey, ") + "value.SyncTime, value.OtherTime, default)") : "value";
#>
    [DataContract]
    internal sealed class <#= className #><<#= genericArguments #><#= fusionOption != "Simple" ? ", TResult" : string.Empty #>> : <#= fusionOption == "Disordered" ? "Disordered" : string.Empty #><#= partitionString #>ObserverSubscriptionBase<<#= !partitioned ? string.Empty : "TKey, " #><#= inheritBase #>, TPayload, <#= outputType #>>
    {
<#      if (fusionOption != "Simple")
        { #>
        [SchemaSerialization]
        private readonly FuseModule fuseModule;
        private readonly Action<long, long, TPayload, <#= keyType #>> action;
<#      } #>
<#      if (ingressType == "Interval")
        {
            if (partitioned)
            { #>
        [SchemaSerialization]
        private readonly Expression<Func<TPayload, TKey>> partitionExtractor;
        private readonly Func<TPayload, TKey> partitionFunction;
<#          } #>
        [SchemaSerialization]
        private readonly Expression<Func<TPayload, long>> startEdgeExtractor;
        private readonly Func<TPayload, long> startEdgeFunction;
        [SchemaSerialization]
        private readonly Expression<Func<TPayload, long>> endEdgeExtractor;
        private readonly Func<TPayload, long> endEdgeFunction;
<#      } #>
        public <#= className #>() { }

        public <#= className #>(
            IObservable<<#= inheritBase #>> observable,
<#      if (fusionOption != "Simple")
        { #>
            FuseModule fuseModule,
<#      } #>
<#      if (ingressType == "Interval")
        {
            if (partitioned)
            { #>
            Expression<Func<TPayload, TKey>> partitionExtractor,
<#          } #>
            Expression<Func<TPayload, long>> startEdgeExtractor,
            Expression<Func<TPayload, long>> endEdgeExtractor,
<#      } #>
            string identifier,
            Streamable<<#= keyType #>, <#= outputType #>> streamable,
            IStreamObserver<<#= keyType #>, <#= outputType #>> observer,
            DisorderPolicy disorderPolicy,
            <#= partitionString #>FlushPolicy flushPolicy,
            PeriodicPunctuationPolicy punctuationPolicy,
<#  if (partitioned) { #>
            PeriodicLowWatermarkPolicy lowWatermarkPolicy,
<#  } #>
            OnCompletedPolicy onCompletedPolicy,
            IObserver<OutOfOrder<#= partitionString #>StreamEvent<<#= genericArguments #>>> diagnosticOutput)
            : base(
                observable,
                identifier,
                streamable,
                observer,
                disorderPolicy,
                flushPolicy,
                punctuationPolicy,
<#  if (partitioned) { #>
                lowWatermarkPolicy,
<#  } #>
                onCompletedPolicy,
                diagnosticOutput)
        {
<#      if (fusionOption == "Fused")
        { #>
            this.fuseModule = fuseModule;
            Expression<Action<long, long, TResult, <#= keyType #>>> statement = (s, e, p, k) => this.currentBatch.Add(s, e, k, p);
            Expression<Action> flush = () => FlushContents();
            Expression<Func<bool>> test = () => this.currentBatch.Count == Config.DataBatchSize;
            var full = Expression.Lambda<Action<long, long, TResult, <#= keyType #>>>(
                Expression.Block(
                    statement.Body,
                    Expression.IfThen(test.Body, flush.Body)),
                statement.Parameters);
            var actionExp = fuseModule.Coalesce<TPayload, TResult, <#= keyType #>>(full);
            this.action = actionExp.Compile();
<#      } #>
<#      else if (fusionOption == "Disordered")
        { #>
            this.fuseModule = fuseModule;
            Expression<Action<long, long, TResult, <#= keyType #>>> statement = (s, e, p, k) => Action(s, e, p, k);
            var actionExp = fuseModule.Coalesce<TPayload, TResult, <#= keyType #>>(statement<#= ingressType == "StreamEvent" ? ", true" : string.Empty #>);
            this.action = actionExp.Compile();
<#      } #>
<#      if (ingressType == "Interval")
        {
            if (partitioned)
            { #>
            this.partitionExtractor = partitionExtractor;
            this.partitionFunction = partitionExtractor.Compile();
<#          } #>
            this.startEdgeExtractor = startEdgeExtractor;
            this.startEdgeFunction = startEdgeExtractor.Compile();
            this.endEdgeExtractor = endEdgeExtractor;
            this.endEdgeFunction = endEdgeExtractor.Compile();
<#      } #>
        }

        [ContractInvariantMethod]
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1822:MarkMembersAsStatic", Justification = "Required for code contracts.")]
        private void ObjectInvariant()
        {
            Contract.Invariant(this.startEventInformation != null);
<#      if (!partitioned)
        { #>
            Contract.Invariant(this.currentTime >= StreamEvent.MinSyncTime);
<#      } #>
        }

        [System.Diagnostics.CodeAnalysis.SuppressMessage(
            "Microsoft.StyleCop.CSharp.DocumentationRules",
            "SA1028:CodeMustNotContainTrailingWhitespace",
            Justification = "T4 generation with PushIndent violates Trailing Whitespace rule")]
        public override void OnNext(<#= inheritBase #> <#= ingressType == "StreamEvent" ? "value" : "inputValue" #>)
        {
<#      if (fusionOption == "Disordered")
        {
            if (ingressType == "Interval")
            { #>
            this.action(this.startEdgeFunction(inputValue), this.endEdgeFunction(inputValue), inputValue, <#= !partitioned ? "Empty.Default" : "new PartitionKey<TKey>(this.partitionFunction(inputValue))" #>);
<#          }
            else
            { #>
            this.action(value.SyncTime, value.OtherTime, value.Payload, <#= !partitioned ? "Empty.Default" : "new PartitionKey<TKey>(value.PartitionKey)" #>);
<#          } #>
        }

        [System.Diagnostics.CodeAnalysis.SuppressMessage(
            "Microsoft.StyleCop.CSharp.DocumentationRules",
            "SA1028:CodeMustNotContainTrailingWhitespace",
            Justification = "T4 generation with PushIndent violates Trailing Whitespace rule")]
        private void Action(long start, long end, TResult payload, <#= keyType #> actionKey)
        {
            var value = new <#= partitionString #>StreamEvent<<#= !partitioned ? string.Empty : "TKey, " #>TResult>(<#= !partitioned ? string.Empty : "actionKey.Key, " #>start, end, payload);
<#      }
        else if (ingressType == "Interval")
        { #>
            var value = <#= partitionString #>StreamEvent.CreateInterval(<#= !partitioned ? string.Empty : "this.partitionFunction(inputValue), " #>this.startEdgeFunction(inputValue), this.endEdgeFunction(inputValue), inputValue);
<#      } #>

            if (value.Is<#= globalPunctuation #>)
            {
                GenerateAndProcess<#= globalPunctuation #>(value.SyncTime);
                return;
            }

<#      if (partitioned)
        { #>
            // Check to see if we need to generate a low watermark due to PeriodicLowWatermarkPolicy
            if (this.lowWatermarkPolicyType == PeriodicLowWatermarkPolicyType.Time &&
                value.SyncTime > this.lowWatermarkTimestampLag)
            {
                var newLowWatermark = value.SyncTime - this.lowWatermarkTimestampLag;
                if ((ulong)(newLowWatermark - this.lowWatermark.quantizedForLowWatermarkGeneration) >= this.lowWatermarkGenerationPeriod)
                {
                    // SyncTime is sufficiently high to generate a new watermark, but first snap it to the nearest generationPeriod boundary
                    var newLowWatermarkSnapped = newLowWatermark.SnapToLeftBoundary((long)this.lowWatermarkGenerationPeriod);
                    GenerateAndProcessLowWatermark(newLowWatermarkSnapped);
                }
            }

<#      }
        if (latencyOption == "WithLatency")
        {
            if (partitioned)
            { #>
            if (!this.currentTime.TryGetValue(value.PartitionKey, out long moveFrom) || moveFrom < this.lowWatermark.rawValue)
            {
                moveFrom = this.lowWatermark.rawValue;
            }

            if (!this.partitionHighWatermarks.ContainsKey(value.PartitionKey))
            {
                this.partitionHighWatermarks.Add(value.PartitionKey, this.lowWatermark.rawValue);

                if (this.highWatermarkToPartitionsMap.TryGetValue(this.lowWatermark.rawValue, out HashSet<TKey> keySet)) keySet.Add(value.PartitionKey);
                else this.highWatermarkToPartitionsMap.Add(this.lowWatermark.rawValue, new HashSet<TKey> { value.PartitionKey });
            }
<#          }
            else
            { #>
            long moveFrom = this.currentTime;
<#          } #>
            long moveTo = moveFrom;

            // Events at the reorder boundary or earlier - are handled using default processing policies
            if (value.SyncTime <= moveFrom)
            {
                Process(ref value);
                return;
            }

            var oldTime = <#= highWatermark #>;
            if (value.SyncTime > oldTime)
            {
                <#= highWatermark #> = value.SyncTime;

<#          if (partitioned)
            { #>
                var oldSet = this.highWatermarkToPartitionsMap[oldTime];
                if (oldSet.Count <= 1) this.highWatermarkToPartitionsMap.Remove(oldTime);
                else oldSet.Remove(value.PartitionKey);

                if (this.highWatermarkToPartitionsMap.TryGetValue(value.SyncTime, out HashSet<TKey> set)) set.Add(value.PartitionKey);
                else this.highWatermarkToPartitionsMap.Add(value.SyncTime, new HashSet<TKey> { value.PartitionKey });

<#          }
            if (ingressType == "StreamEvent" && partitioned)
            {
                PushIndent("    "); #>
            if (value.IsData)
            {
                // moveTo for punctuations is updated below
<#          } #>
                moveTo = value.SyncTime - this.reorderLatency;
                if (moveTo < StreamEvent.MinSyncTime) moveTo = StreamEvent.MinSyncTime;
                if (moveTo < moveFrom) moveTo = moveFrom;
            }
<#          if (ingressType == "StreamEvent" && partitioned)
            {
                PopIndent(); #>
            }

            if (value.IsPunctuation)
            {
                moveTo = Math.Max(moveFrom, value.SyncTime);
            }
<#          } #>

            if (moveTo > moveFrom)
            {
                if (this.priorityQueueSorter != null)
                {
                    <#= partitionString #>StreamEvent<<#= adjustedGenericArgs #>> resultEvent;

                    while ((!this.priorityQueueSorter.IsEmpty()) && this.priorityQueueSorter.Peek().SyncTime <= moveTo)
                    {
                        resultEvent = this.priorityQueueSorter.Dequeue();
                        Process(ref resultEvent);
                    }
                }
                else
                {
                    // Extract and process data in-order from impatience, until timestamp of moveTo
                    PooledElasticCircularBuffer<<#= baseStructure #>> streamEvents = this.impatienceSorter.DequeueUntil(<#= !partitioned ? string.Empty : "value.PartitionKey, " #>moveTo, out bool recheck);

                    if (streamEvents != null)
                    {
                        <#= baseStructure #> resultEvent;
                        while ((streamEvents.Count > 0) && ((!recheck) || (streamEvents.PeekFirst().SyncTime <= moveTo)))
                        {
                            resultEvent = streamEvents.Dequeue();
                            Process(ref resultEvent);
                        }
                    }

                    if (!recheck && (streamEvents != null))
                        this.impatienceSorter.Return(<#= !partitioned ? string.Empty : "value.PartitionKey, " #>streamEvents);
                }
            }

            if (value.SyncTime == moveTo)
            {
                Process(ref value);
                return;
            }

            // Enqueue value into impatience
            if (this.priorityQueueSorter != null) this.priorityQueueSorter.Enqueue(value);
            else this.impatienceSorter.Enqueue(ref value);

            UpdateCurrentTime(<# if (partitioned) { #>value.PartitionKey, <# } #>moveTo, fromEvent: false);
        }

        [System.Diagnostics.CodeAnalysis.SuppressMessage(
            "Microsoft.StyleCop.CSharp.DocumentationRules",
            "SA1028:CodeMustNotContainTrailingWhitespace",
            Justification = "T4 generation with PushIndent violates Trailing Whitespace rule")]
        private void Process(ref <#= baseStructure #> value)
        {
<#      }

        if (ingressType == "StreamEvent")
        { #>
            Contract.Assume(value.SyncTime != value.OtherTime);

<#      }

        if (ingressType == "StreamEvent" && latencyOption == "WithLatency")
        { #>
            if (value.Is<#= globalPunctuation #>)
            {
                GenerateAndProcess<#= globalPunctuation #>(value.SyncTime);
                return;
            }

<#      }
        if (!partitioned)
        { #>
            long current = this.currentTime;
<#      }
        else
        { #>
            // Update global high water mark if necessary
            this.highWatermark = Math.Max(this.highWatermark, value.SyncTime);

            if (this.punctuationPolicyType == PeriodicPunctuationPolicyType.Time && !this.lastPunctuationTime.ContainsKey(value.PartitionKey))
                UpdatePunctuation(value.PartitionKey, this.lowWatermark.rawValue, this.lowWatermark.quantizedForPunctuationGeneration);

            // Retrieve current time for this partition, updating currentTime if necessary
            if (!this.currentTime.TryGetValue(value.PartitionKey, out long current))
            {
                current = this.lowWatermark.rawValue;
            }
            else if (current < this.lowWatermark.rawValue)
            {
                current = this.lowWatermark.rawValue;
                UpdateCurrentTime(value.PartitionKey, this.lowWatermark.rawValue);
            }
<#      } #>

            var outOfOrder = value.SyncTime < current;
            if (this.punctuationPolicyType == PeriodicPunctuationPolicyType.Time)
            {
<#      if (ingressType == "StreamEvent" && partitioned)
        { #>
                // Track punctuation
                if (value.IsPunctuation && value.SyncTime > this.lastPunctuationTime[value.PartitionKey].lastPunctuation)
                    UpdatePunctuation(value.PartitionKey, value.SyncTime);

<#      } #>
                // out of order events shouldn't count, and if the disorder policy adjusts their sync time, then it
                // will be made equal to a timestamp already seen earlier in the sequence and this would have triggered
                // (if necessary) when that timestamp was seen.
<#      if (!partitioned)
        { #>
                ulong delta = (ulong)(value.SyncTime - this.lastPunctuationTime);
                if (!outOfOrder && delta >= this.punctuationGenerationPeriod)
                {
                    // SyncTime is sufficiently high to generate a new punctuation, but first snap it to the nearest generationPeriod boundary
                    var punctuationTimeQuantized = value.SyncTime.SnapToLeftBoundary((long)this.punctuationGenerationPeriod);
#if DEBUG
                    Debug.Assert(punctuationTimeQuantized >= LastEventTime(), "Bug in punctuation quantization logic");
#endif
                    OnPunctuation(StreamEvent.CreatePunctuation<<#= fusionOption == "Disordered" ? "TResult" : "TPayload" #>>(punctuationTimeQuantized));
                }
<#      }
        else
        { #>
                if (!outOfOrder && this.punctuationGenerationPeriod > 0)
                {
                    // We use lowWatermark as the baseline in the delta computation because a low watermark implies
                    // punctuations for all partitions
                    var prevPunctuation = Math.Max(this.lastPunctuationTime[value.PartitionKey].lastPunctuationQuantized, this.lowWatermark.quantizedForPunctuationGeneration);
                    if ((ulong)(value.SyncTime - prevPunctuation) >= this.punctuationGenerationPeriod)
                    {
                        // SyncTime is sufficiently high to generate a new punctuation, but first snap it to the nearest generationPeriod boundary
                        var punctuationTimeQuantized = value.SyncTime.SnapToLeftBoundary((long)this.punctuationGenerationPeriod);
#if DEBUG
                        Debug.Assert(punctuationTimeQuantized >= LastEventTime(value.PartitionKey), "Bug in punctuation quantization logic");
#endif
                        OnPunctuation(value.CreatePunctuation(punctuationTimeQuantized));
                    }
                }
<#      } #>
            }

<#      if (ingressType == "StreamEvent")
        { #>
            // check for out of order event
<#          if (partitioned)
            { #>
            if (value.IsPunctuation)
            {
                OnPunctuation(value.CreatePunctuation(outOfOrder ? current : value.SyncTime));
            }
            else
            {
<#              PushIndent("    ");
            }
        } #>
            if (this.disorderPolicyType == DisorderPolicyType.Throw)
            {
                if (outOfOrder)
                {
                    throw new IngressException($"Out-of-order event encountered during ingress, under a disorder policy of Throw: value.SyncTime: {value.SyncTime}, current:{current}");
                }
            }
            else
            {
<#      if (ingressType == "StreamEvent")
        { #>
                // end events and interval events just get dropped
                Tuple<long, <#= fusionOption == "Disordered" ? "TResult" : "TPayload" #>> key;
                ElasticCircularBuffer<AdjustInfo> q;
                switch (value.Kind)
                {
                    case StreamEventKind.Start:
                        if (outOfOrder)
                        {
                            key = Tuple.Create(value.SyncTime, value.Payload);
                            if (!this.startEventInformation.TryGetValue(key, out q))
                            {
                                q = new ElasticCircularBuffer<AdjustInfo>();
                                this.startEventInformation.Add(key, q);
                                var x = new AdjustInfo(current);
                                q.Enqueue(ref x);
                            }
                            else
                            {
                                var last = q.PeekLast();
                                if (last.modifiedStartTime == current) last.numberOfOccurrences++;
                                else
                                {
                                    var x = new AdjustInfo(current);
                                    q.Enqueue(ref x);
                                }
                            }

                            if (this.disorderPolicyType == DisorderPolicyType.Drop)
                            {
                                this.diagnosticOutput?.OnNext(OutOfOrder<#= partitionString #>StreamEvent.Create(<#= streamEventFromValue #>, default));
                                return; // drop
                            }
                            else
                            {
                                this.diagnosticOutput?.OnNext(OutOfOrder<#= partitionString #>StreamEvent.Create(<#= streamEventFromValue #>, new long?(current - value.SyncTime)));
                                value = new <#= partitionString #>StreamEvent<<#= adjustedGenericArgs #>>(<#= !partitioned ? string.Empty : "value.PartitionKey, " #>current, StreamEvent.InfinitySyncTime, value.Payload);
                            }
                        }
                        break;

                    case StreamEventKind.Interval:
<#      } #>
                        if (outOfOrder)
                        {
                            if (this.disorderPolicyType == DisorderPolicyType.Drop)
                            {
                                this.diagnosticOutput?.OnNext(OutOfOrder<#= partitionString #>StreamEvent.Create(<#= streamEventFromValue #>, default));
                                return; // drop
                            }
                            else
                            {
                                if (current >= value.OtherTime)
                                {
                                    this.diagnosticOutput?.OnNext(OutOfOrder<#= partitionString #>StreamEvent.Create(<#= streamEventFromValue #>, default));
                                    return; // drop
                                }

                                this.diagnosticOutput?.OnNext(OutOfOrder<#= partitionString #>StreamEvent.Create(<#= streamEventFromValue #>, new long?(current - value.SyncTime)));
                                value = new <#= partitionString #>StreamEvent<<#= adjustedGenericArgs #>>(<#= !partitioned ? string.Empty : "value.PartitionKey, " #>current, value.OtherTime, value.Payload);
                            }
                        }
<#      if (ingressType == "StreamEvent")
        { #>
                        break;

                    case StreamEventKind.End:
                        // it may not be out of order, but did we drop/adjust the corresponding start event?
                        key = Tuple.Create(value.OtherTime, value.Payload);
                        if (this.startEventInformation.TryGetValue(key, out q))
                        {
                            Contract.Assume(!q.IsEmpty());
                            var firstElement = q.PeekFirst();
                            firstElement.numberOfOccurrences--;
                            if (firstElement.numberOfOccurrences == 0)
                            {
                                q.Dequeue(); // throw away returned value
                                if (q.Count == 0) this.startEventInformation.Remove(key);
                            }
                            var adjustedTime = firstElement.modifiedStartTime;

                            if (this.disorderPolicyType == DisorderPolicyType.Drop)
                            {
                                this.diagnosticOutput?.OnNext(OutOfOrder<#= partitionString #>StreamEvent.Create(<#= streamEventFromValue #>, default));
                                return; // drop
                            }
                            else
                            {
                                this.diagnosticOutput?.OnNext(OutOfOrder<#= partitionString #>StreamEvent.Create(<#= streamEventFromValue #>, new long?(current - value.SyncTime)));
                                value = new <#= partitionString #>StreamEvent<<#= adjustedGenericArgs #>>(<#= !partitioned ? string.Empty : ("value.PartitionKey, ") #>outOfOrder ? current : value.SyncTime, adjustedTime, value.Payload);
                            }
                        }
                        else if (outOfOrder)
                        {
                            if (this.disorderPolicyType == DisorderPolicyType.Drop)
                            {
                                this.diagnosticOutput?.OnNext(OutOfOrder<#= partitionString #>StreamEvent.Create(<#= streamEventFromValue #>, default));
                                return; // drop
                            }
                            else
                            {
                                this.diagnosticOutput?.OnNext(OutOfOrder<#= partitionString #>StreamEvent.Create(<#= streamEventFromValue #>, new long?(current - value.SyncTime)));
                                value = new <#= partitionString #>StreamEvent<<#= adjustedGenericArgs #>>(<#= !partitioned ? string.Empty : ("value.PartitionKey, ") #>current, value.OtherTime, value.Payload);
                            }
                        }

                        break;
                    default:
                        Contract.Assert(false, "switch meant to be exhaustive");
                        throw new InvalidOperationException("Unsupported stream event kind: " + value.Kind.ToString());
                }
<#      } #>
            }

<#      if (fusionOption == "Fused")
        { #>
            this.action(value.SyncTime, value.OtherTime, value.Payload, <#= !partitioned ? "Empty.Default" : "new PartitionKey<TKey>(value.PartitionKey)" #>);
<#      }
        else
        { #>
            this.currentBatch.Add(value.SyncTime, value.OtherTime, <#= !partitioned ? "Empty.Default" : "new PartitionKey<TKey>(value.PartitionKey)" #>, value.Payload);
            if (this.currentBatch.Count == Config.DataBatchSize)
            {
                if (this.flushPolicy == <#= partitionString #>FlushPolicy.FlushOnBatchBoundary) OnFlush();
                else FlushContents();
            }
<#      }
        if (partitioned && ingressType == "StreamEvent")
        {
            PopIndent(); #>
            }
<#      } #>

            UpdateCurrentTime(<# if (partitioned) { #>value.PartitionKey, <# } #>value.SyncTime);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private void UpdateCurrentTime(<# if (partitioned) { #>TKey partitionKey, <# } #>long time, bool fromEvent = true)
        {
<#      if (!partitioned)
        { #>
            if (this.currentTime < time)
            {
                this.currentTime = time;
            }
#if DEBUG
            if (fromEvent && this.lastEventTime < time)
            {
                this.lastEventTime = time;
            }
#endif
<#      }
        else
        { #>
            if (!this.currentTime.TryGetValue(partitionKey, out long oldCurrentTime) || oldCurrentTime < time)
            {
                this.currentTime[partitionKey] = time;
            }
#if DEBUG
            if (fromEvent && (!this.lastEventTime.TryGetValue(partitionKey, out long oldEventTime) || oldEventTime < time))
            {
                this.lastEventTime[partitionKey] = time;
            }
#endif
<#      }#>
        }

        [System.Diagnostics.CodeAnalysis.SuppressMessage(
            "Microsoft.StyleCop.CSharp.DocumentationRules",
            "SA1028:CodeMustNotContainTrailingWhitespace",
            Justification = "T4 generation with PushIndent violates Trailing Whitespace rule")]
        private void GenerateAndProcess<#= globalPunctuation #>(long syncTime)
        {
            if (syncTime <= <#= partitioned ? "this.lowWatermark.rawValue" : "this.lastPunctuationTime" #>) return;

<#      if (!partitioned)
        { #>
            // Update the <#= globalPunctuation #> to be at least the currentTime, so the <#= globalPunctuation #>
            // is not before the preceding data event.
<#          if (latencyOption == "WithLatency")
            { #>
            // Note that currentTime only reflects events already processed, and excludes events in the reorder buffer.
<#          } #>
            syncTime = Math.Max(syncTime, this.currentTime);

<#      } #>
<#      if (latencyOption == "WithLatency")
        { #>
            // Process events queued for reorderLatency up to the <#= globalPunctuation #> syncTime
            if (this.priorityQueueSorter != null)
            {
                <#= baseStructure #> resultEvent;
                while ((!this.priorityQueueSorter.IsEmpty()) && this.priorityQueueSorter.Peek().SyncTime <= syncTime)
                {
                    resultEvent = this.priorityQueueSorter.Dequeue();
                    Process(ref resultEvent);
                }
            }
            else
            {
<#          if (partitioned)
            { #>
                bool recheck;
                var events = this.impatienceSorter.DequeueUntil(syncTime);

                int index = FastDictionary<TKey, Tuple<bool, PooledElasticCircularBuffer<PartitionedStreamEvent<TKey, TPayload>>>>.IteratorStart;
                while (events.Iterate(ref index))
                {
                    var entry = events.entries[index];
                    recheck = entry.value.Item1;
                    var streamEvents = entry.value.Item2;
<#              PushIndent("    ");
            }
            else
            { #>
                var streamEvents = this.impatienceSorter.DequeueUntil(syncTime, out bool recheck);
<#          } #>
                if (streamEvents != null)
                {
                    <#= baseStructure #> resultEvent;
                    while ((streamEvents.Count > 0) && ((!recheck) || (streamEvents.PeekFirst().SyncTime <= syncTime)))
                    {
                        resultEvent = streamEvents.Dequeue();
                        Process(ref resultEvent);
                    }
                    if (!recheck) this.impatienceSorter.Return(<#= !partitioned ? string.Empty : "entry.key, " #>streamEvents);
                }
<#          if (partitioned)
            {
                PopIndent(); #>
                }
<#          } #>
            }

<#      } #>
            // Update cached global times
            this.highWatermark = Math.Max(syncTime, this.highWatermark);
<#      if (partitioned)
        { #>
            if (this.lowWatermark.rawValue < syncTime)
            {
                UpdateLowWatermark(syncTime);
<#          if (latencyOption == "WithLatency")
            { #>

                // Gather keys whose high watermarks are before the new low watermark
                var expiredWatermarkKVPs = new List<KeyValuePair<long, HashSet<TKey>>>();
                foreach (var keyValuePair in this.highWatermarkToPartitionsMap)
                {
                    // Since highWatermarkToPartitionsMap is sorted, we can stop as soon as we reach the threshold
                    if (keyValuePair.Key >= this.lowWatermark.rawValue) break;

                    expiredWatermarkKVPs.Add(keyValuePair);
                }

                // Clean up state from expired partitions
                foreach (var expiredWatermarkKVP in expiredWatermarkKVPs)
                {
                    var expiredWatermark = expiredWatermarkKVP.Key;
                    this.highWatermarkToPartitionsMap.Remove(expiredWatermark);

                    var expiredKeys = expiredWatermarkKVP.Value;
                    foreach (var expiredKey in expiredKeys)
                    {
                        this.lastPunctuationTime.Remove(expiredKey);
                        this.partitionHighWatermarks.Remove(expiredKey);
                        this.currentTime.Remove(expiredKey);
#if DEBUG
                        this.lastEventTime.Remove(expiredKey);
#endif
                    }
                }
<#          } #>
            }
<#      }
        else
        { #>
            UpdateCurrentTime(syncTime);
            this.lastPunctuationTime = Math.Max(
                syncTime.SnapToLeftBoundary((long)this.punctuationGenerationPeriod),
                this.lastPunctuationTime);
<#      } #>

            // Add <#= globalPunctuation #> to batch
            var count = this.currentBatch.Count;
            this.currentBatch.vsync.col[count] = syncTime;
            this.currentBatch.vother.col[count] = <#= partitionString #>StreamEvent.<#= globalPunctuation #>OtherTime;
            this.currentBatch.bitvector.col[count >> 6] |= (1L << (count & 0x3f));
            this.currentBatch.key.col[count] = default;
            this.currentBatch[count] = default;
            this.currentBatch.hash.col[count] = 0;
            this.currentBatch.Count = count + 1;

            // Flush if necessary
            if (this.flushPolicy == <#= partitionString#>FlushPolicy.FlushOn<#= globalPunctuation #> ||
                (this.flushPolicy == <#= partitionString#>FlushPolicy.FlushOnBatchBoundary && this.currentBatch.Count == Config.DataBatchSize))
            {
                OnFlush();
            }
            else if (this.currentBatch.Count == Config.DataBatchSize)
            {
                FlushContents();
            }
        }

<#      if (partitioned && latencyOption == "WithLatency")
        { #>
        protected override void UpdatePointers()
        {
            foreach (var kvp in this.partitionHighWatermarks)
            {
                if (this.highWatermarkToPartitionsMap.TryGetValue(kvp.Value, out HashSet<TKey> set))
                    set.Add(kvp.Key);
                else
                    this.highWatermarkToPartitionsMap.Add(kvp.Value, new HashSet<TKey> { kvp.Key });
            }
        }

<#      } #>
        protected override void OnCompleted(long punctuationTime)
        {
            GenerateAndProcess<#= globalPunctuation #>(punctuationTime);

            // Flush, but if we just flushed due to the punctuation generated above
            if (this.flushPolicy != <#= partitionString #>FlushPolicy.FlushOn<#= globalPunctuation #>)
                OnFlush();
        }
    }

<#  } // end foreach loops #>
}